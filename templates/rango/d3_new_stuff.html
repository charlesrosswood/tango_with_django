{% extends "rango/base.html" %}

{% load static %}

{% block title %}Visualise data{% endblock %}

{% block css_and_js_imports %}
    <link rel="stylesheet" type="text/css" href="{% static 'css/d3stuff.css' %}">
    <link rel="stylesheet" type="text/css" href="{% static 'css/jquery.nouislider.css' %}">

    <script type="text/javascript" src="{% static 'js/d3.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'js/jquery.nouislider.min.js' %}"></script>
{% endblock %}

{% block page_title %}Visualise data{% endblock %} 

{% block content %}

<div id="graph" class="aGraph" style="position:relative;top:0px;left:0;">

<select name="category_choice" id="category_choice">
    {% for category in graph_types %}
        {% if category == "totals" %}
            <option value="{{ category }}" selected> {{ category }} </option>
        {% else %}
            <option value="{{ category }}"> {{ category }} </option>
        {% endif %}
    {% endfor %}
</select>

<div id="bin_range"></div>

<div id="x_range"></div>


</div>
{% endblock %}

{% block js %}

<script>
    // define dimensions of graph
    var m = [80, 80, 80, 80]; // margins
    var w = 1000 - m[1] - m[3]; // width
    var h = 400 - m[0] - m[2]; // height

    $(window).resize(function(){
     setInterval(function() {
         $('.aGraph').css({
             position:'absolute',
             left: ($(window).width() - $('.aGraph').outerWidth())/2,
             top: ($(window).height() - $('.aGraph').outerHeight())/2,
         }).fadeIn(5000);
     }, 20);
        

    });
    
    // To initially run the function:
    $(window).resize();

    // Max a nice slider for x range
    $("#x_range").noUiSlider({
        start: [0.00, 1.00],
        connect: true,
        range: {
            'min': 0,
            'max': 1.0
        }
    });
    $("#x_range").width(w);
    $("#x_range").css('marginLeft', m[0] + 'px');

    // Max a nice slider for bin range
    $("#bin_range").noUiSlider({
        start: 5,
        step: 1,
        range: {
            'min': 0,
            'max': 9
        }
    });
    $("#bin_range").width(w);
    $("#bin_range").css('marginLeft', m[0] + 'px');



    var graphs = {{ graph|safe }}; // Django markup to get the data

    var categoryChoice = getCategoryValue();
    var binRange = parseInt($("#bin_range").val());
    var xMin = parseFloat($("#x_range").val()[0]);
    var xMax = parseFloat($("#x_range").val()[1]);
    
    drawGraph(categoryChoice, binRange, xMin, xMax); // this draws the graph on page load

    // A jQuery event to update the graph on changing the bin size slider
    $("#bin_range").on('change', function() {
        categoryChoice = getCategoryValue();
        binRange = parseInt($("#bin_range").val());
        xMin = parseFloat($("#x_range").val()[0]);
        xMax = parseFloat($("#x_range").val()[1]);

        updateGraph(categoryChoice, binRange, xMin, xMax);
    });
    
    $("#x_range").on('change', function() {
        categoryChoice = getCategoryValue();
        binRange = parseInt($("#bin_range").val());
        xMin = parseFloat($("#x_range").val()[0]);
        xMax = parseFloat($("#x_range").val()[1]);

        updateGraph(categoryChoice, binRange, xMin, xMax);
    });

    // a jQuery event to update the graph on changing the category from the drop down
    $('#category_choice').on('change', function (e) {
        categoryChoice = getCategoryValue();
        binRange = parseInt($("#bin_range").val());
        xMin = parseFloat($("#x_range").val()[0]);
        xMax = parseFloat($("#x_range").val()[1]);

        updateGraph(categoryChoice, binRange, xMin, xMax);
    });

    // A function to perform Python-style unzipping
    // ============================================
    function Unzip(array, index_to_unzip) {
        var unzipped_array = [];    

        for (var i=0; i < array.length; i++) {
            unzipped_array.push(array[i][index_to_unzip]);
        };  

        return unzipped_array;
    };

    // A function to get the value of the slider
    // =========================================
    function getBinRange() {
        return parseFloat($("#binRange").val());
    };
    
    // A function to get the value of the slider
    // =========================================
    function getxMin() {
        return parseFloat($("#xMin").val());
    };
    
    // A function to get the value of the slider
    // =========================================
    function getxMax() {
        return parseFloat($("#xMax").val());
    };

    // A function to get the value of the category drop down menu
    // ==========================================================
    function getCategoryValue() {
        return $('#category_choice').val();
    }

    // A function to draw the graph first time around
    // =========================================
    function drawGraph(categoryChoice, binRange, xMin, xMax){

        console.log(categoryChoice);

        var data = graphs[categoryChoice][binRange]; // Actually exracting the dataset we want
        var data_x_min = d3.min(Unzip(data, 0));
        var data_x_max = d3.max(Unzip(data, 0));
        var data_x_range = Math.abs(data_x_max-data_x_min); 

        var x_axis_min = data_x_min + (xMin*data_x_range);
        var x_axis_max = data_x_max - ((1.0-xMax)*data_x_range);

        var graph = d3.select(".aGraph").append("svg")
              .attr("width", w + m[1] + m[3])
              .attr("height", h + m[0] + m[2])
            .append("g")
              .attr("transform", "translate(" + m[3] + "," + m[0] + ")");
        

        var x = d3.scale.linear().domain([x_axis_min, x_axis_max]).range([0, w]);
        // Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
        // var y = d3.scale.linear().domain([y_min, y_max]).range([h, 0]);
        var y = d3.scale.linear().domain([d3.min(Unzip(data, 1)), d3.max(Unzip(data, 1))]).range([h, 0]);

        // create yAxis
        var xAxis = d3.svg.axis().scale(x).tickSize(-h).tickSubdivide(true);
        // create left yAxis
        var yAxisLeft = d3.svg.axis().scale(y).ticks(4).orient("left");
        
        graph.append("g")
              .attr("class", "x axis")
              .attr("transform", "translate(0," + h + ")")
              .call(xAxis);

        graph.append("g")
              .attr("class", "y axis")
              // .attr("transform", "translate(-25,0)")
              .call(yAxisLeft);

        // Add the x-axis labels    
        graph.append("text")
            .attr("class", "x label")
            .attr("text-anchor", "end")
            .attr("x", w-20)
            .attr("y", h+40)
            .text("Amount spent Â£");

        // Add the y-axis to the left
        graph.append("text")
            .attr("class", "y label")
            .attr("text-anchor", "end")
            .attr("y", -70)
            .attr("dy", ".75em")
            .attr("transform", "rotate(-90)")
            .text("Frequency of spend");
        // create a line function that can convert data[] into x and y points
        var line = d3.svg.line()
            // assign the X function to plot our line as we wish
            .x(function(d) { 
                // return the X coordinate where we want to plot this datapoint
                return x(d[0]); 
            })
            .y(function(d) { 
                // return the Y coordinate where we want to plot this datapoint
                return y(d[1]); 
            })
            .interpolate("basis");

        graph.append("path")
            .attr("d", line(data));
    };

    // A function to update the graph with a transition
    // ================================================
    function updateGraph(categoryChoice, binRange, xMin, xMax) {

        console.log(categoryChoice);
        
        data = graphs[categoryChoice][binRange];
        data_x_min = d3.min(Unzip(data, 0));
        data_x_max = d3.max(Unzip(data, 0));
        data_x_range = Math.abs(data_x_max-data_x_min); 

        x_axis_min = data_x_min + (xMin*data_x_range);
        x_axis_max = data_x_max - ((1.0-xMax)*data_x_range);
        
        line = d3.svg.line()
            // assign the X function to plot our line as we wish
            .x(function(d) { 
                // return the X coordinate where we want to plot this datapoint
                return x(d[0]); 
            })
            .y(function(d) { 
                // return the Y coordinate where we want to plot this datapoint
                return y(d[1]); 
            })
        .interpolate("basis");

        
        x = d3.scale.linear().domain([x_axis_min, x_axis_max]).range([0, w]);
        // Y scale will fit values from 0-10 within pixels h-0 (Note the inverted domain for the y-scale: bigger is up!)
        // var y = d3.scale.linear().domain([y_min, y_max]).range([h, 0]);
        y = d3.scale.linear().domain([d3.min(Unzip(data, 1)), d3.max(Unzip(data, 1))]).range([h, 0]);
        
            // create yAxis
        xAxis = d3.svg.axis().scale(x).tickSize(-h).tickSubdivide(true);
        // create left yAxis
        yAxisLeft = d3.svg.axis().scale(y).ticks(4).orient("left");
        // x.domain(d3.extent(data_new, function(d) { return x(d[0]); }));
        // y.domain([0, d3.max(data_new, function(d) { return x(d[1]); })]);

        graph = d3.select(".aGraph").transition();

        graph.select(".x.axis")
            // .duration(750)
            .call(xAxis);

        graph.select(".y.axis")
            // .duration(750)
            .call(yAxisLeft);
        // graph.transition().attr("d", line(data));      
            // .duration(750)
        graph.selectAll("path")
            .attr("d", line(data));
    };


</script>

{% endblock %}





